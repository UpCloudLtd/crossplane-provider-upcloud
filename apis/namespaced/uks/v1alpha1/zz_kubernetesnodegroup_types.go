/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type CloudNativePlanInitParameters struct {

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	StorageSize *float64 `json:"storageSize,omitempty" tf:"storage_size,omitempty"`

	// (String) The storage tier to use.
	// The storage tier to use.
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type CloudNativePlanObservation struct {

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	StorageSize *float64 `json:"storageSize,omitempty" tf:"storage_size,omitempty"`

	// (String) The storage tier to use.
	// The storage tier to use.
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type CloudNativePlanParameters struct {

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	// +kubebuilder:validation:Optional
	StorageSize *float64 `json:"storageSize,omitempty" tf:"storage_size,omitempty"`

	// (String) The storage tier to use.
	// The storage tier to use.
	// +kubebuilder:validation:Optional
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type CustomPlanInitParameters struct {

	// (Number) The number of CPU cores dedicated to individual node group nodes.
	// The number of CPU cores dedicated to individual node group nodes.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// (Number) The amount of memory in megabytes to assign to individual node group node. Value needs to be divisible by 1024.
	// The amount of memory in megabytes to assign to individual node group node. Value needs to be divisible by 1024.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	StorageSize *float64 `json:"storageSize,omitempty" tf:"storage_size,omitempty"`

	// (String) The storage tier to use.
	// The storage tier to use.
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type CustomPlanObservation struct {

	// (Number) The number of CPU cores dedicated to individual node group nodes.
	// The number of CPU cores dedicated to individual node group nodes.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// (Number) The amount of memory in megabytes to assign to individual node group node. Value needs to be divisible by 1024.
	// The amount of memory in megabytes to assign to individual node group node. Value needs to be divisible by 1024.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	StorageSize *float64 `json:"storageSize,omitempty" tf:"storage_size,omitempty"`

	// (String) The storage tier to use.
	// The storage tier to use.
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type CustomPlanParameters struct {

	// (Number) The number of CPU cores dedicated to individual node group nodes.
	// The number of CPU cores dedicated to individual node group nodes.
	// +kubebuilder:validation:Optional
	Cores *float64 `json:"cores" tf:"cores,omitempty"`

	// (Number) The amount of memory in megabytes to assign to individual node group node. Value needs to be divisible by 1024.
	// The amount of memory in megabytes to assign to individual node group node. Value needs to be divisible by 1024.
	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory" tf:"memory,omitempty"`

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	// +kubebuilder:validation:Optional
	StorageSize *float64 `json:"storageSize" tf:"storage_size,omitempty"`

	// (String) The storage tier to use.
	// The storage tier to use.
	// +kubebuilder:validation:Optional
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type GpuPlanInitParameters struct {

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	StorageSize *float64 `json:"storageSize,omitempty" tf:"storage_size,omitempty"`

	// (String) The storage tier to use.
	// The storage tier to use.
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type GpuPlanObservation struct {

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	StorageSize *float64 `json:"storageSize,omitempty" tf:"storage_size,omitempty"`

	// (String) The storage tier to use.
	// The storage tier to use.
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type GpuPlanParameters struct {

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	// +kubebuilder:validation:Optional
	StorageSize *float64 `json:"storageSize,omitempty" tf:"storage_size,omitempty"`

	// (String) The storage tier to use.
	// The storage tier to use.
	// +kubebuilder:validation:Optional
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type KubeletArgsInitParameters struct {

	// (String) Kubelet argument key.
	// Kubelet argument key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Kubelet argument value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type KubeletArgsObservation struct {

	// (String) Kubelet argument key.
	// Kubelet argument key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Kubelet argument value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type KubeletArgsParameters struct {

	// (String) Kubelet argument key.
	// Kubelet argument key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Kubelet argument value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type KubernetesNodeGroupInitParameters struct {

	// affinity policy is considered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.
	// If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is considered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.
	AntiAffinity *bool `json:"antiAffinity,omitempty" tf:"anti_affinity,omitempty"`

	// (Block List) Resource properties for Cloud Native plan storage configuration. This block is optional for Cloud Native plans. (see below for nested schema)
	// Resource properties for Cloud Native plan storage configuration. This block is optional for Cloud Native plans.
	CloudNativePlan []CloudNativePlanInitParameters `json:"cloudNativePlan,omitempty" tf:"cloud_native_plan,omitempty"`

	// (Block List) Resource properties for custom plan. This block is required for custom plans only. (see below for nested schema)
	// Resource properties for custom plan. This block is required for `custom` plans only.
	CustomPlan []CustomPlanInitParameters `json:"customPlan,omitempty" tf:"custom_plan,omitempty"`

	// (Block List) Resource properties for GPU plan storage configuration. This block is optional for GPU plans. (see below for nested schema)
	// Resource properties for GPU plan storage configuration. This block is optional for GPU plans.
	GpuPlan []GpuPlanInitParameters `json:"gpuPlan,omitempty" tf:"gpu_plan,omitempty"`

	// -. The API will prefix the arguments with -- when preparing kubelet call.
	// Additional arguments for kubelet for the nodes in this group. Configure the arguments without leading `--`. The API will prefix the arguments with `--` when preparing kubelet call.
	//
	// Note that these arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args.
	KubeletArgs []KubeletArgsInitParameters `json:"kubeletArgs,omitempty" tf:"kubelet_args,omitempty"`

	// value pairs to classify the node_group.
	// User defined key-value pairs to classify the node_group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Number) Amount of nodes to provision in the node group.
	// Amount of nodes to provision in the node group.
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// (String) The server plan used for the node group. You can list available plans with upctl server plans
	// The server plan used for the node group. You can list available plans with `upctl server plans`
	Plan *string `json:"plan,omitempty" tf:"plan,omitempty"`

	// (Set of String) You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// +listType=set
	SSHKeys []*string `json:"sshKeys,omitempty" tf:"ssh_keys,omitempty"`

	// at-rest and none.
	// The storage encryption strategy to use for the nodes in this group. If not set, the cluster's storage encryption strategy will be used, if applicable. Valid values are `data-at-rest` and `none`.
	StorageEncryption *string `json:"storageEncryption,omitempty" tf:"storage_encryption,omitempty"`

	// (Block Set) Taints for the nodes in this group. (see below for nested schema)
	// Taints for the nodes in this group.
	Taint []TaintInitParameters `json:"taint,omitempty" tf:"taint,omitempty"`

	// (Boolean) If set to false, nodes in this group will not have access to utility network.
	// If set to false, nodes in this group will not have access to utility network.
	UtilityNetworkAccess *bool `json:"utilityNetworkAccess,omitempty" tf:"utility_network_access,omitempty"`
}

type KubernetesNodeGroupObservation struct {

	// affinity policy is considered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.
	// If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is considered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.
	AntiAffinity *bool `json:"antiAffinity,omitempty" tf:"anti_affinity,omitempty"`

	// (Block List) Resource properties for Cloud Native plan storage configuration. This block is optional for Cloud Native plans. (see below for nested schema)
	// Resource properties for Cloud Native plan storage configuration. This block is optional for Cloud Native plans.
	CloudNativePlan []CloudNativePlanObservation `json:"cloudNativePlan,omitempty" tf:"cloud_native_plan,omitempty"`

	// (String) UUID of the cluster.
	// UUID of the cluster.
	Cluster *string `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// (Block List) Resource properties for custom plan. This block is required for custom plans only. (see below for nested schema)
	// Resource properties for custom plan. This block is required for `custom` plans only.
	CustomPlan []CustomPlanObservation `json:"customPlan,omitempty" tf:"custom_plan,omitempty"`

	// (Block List) Resource properties for GPU plan storage configuration. This block is optional for GPU plans. (see below for nested schema)
	// Resource properties for GPU plan storage configuration. This block is optional for GPU plans.
	GpuPlan []GpuPlanObservation `json:"gpuPlan,omitempty" tf:"gpu_plan,omitempty"`

	// (String) Computed ID of the node group. This is a combination of the cluster UUID and the node group name, separated with a /.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// -. The API will prefix the arguments with -- when preparing kubelet call.
	// Additional arguments for kubelet for the nodes in this group. Configure the arguments without leading `--`. The API will prefix the arguments with `--` when preparing kubelet call.
	//
	// Note that these arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args.
	KubeletArgs []KubeletArgsObservation `json:"kubeletArgs,omitempty" tf:"kubelet_args,omitempty"`

	// value pairs to classify the node_group.
	// User defined key-value pairs to classify the node_group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Number) Amount of nodes to provision in the node group.
	// Amount of nodes to provision in the node group.
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// (String) The server plan used for the node group. You can list available plans with upctl server plans
	// The server plan used for the node group. You can list available plans with `upctl server plans`
	Plan *string `json:"plan,omitempty" tf:"plan,omitempty"`

	// (Set of String) You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// +listType=set
	SSHKeys []*string `json:"sshKeys,omitempty" tf:"ssh_keys,omitempty"`

	// at-rest and none.
	// The storage encryption strategy to use for the nodes in this group. If not set, the cluster's storage encryption strategy will be used, if applicable. Valid values are `data-at-rest` and `none`.
	StorageEncryption *string `json:"storageEncryption,omitempty" tf:"storage_encryption,omitempty"`

	// (Block Set) Taints for the nodes in this group. (see below for nested schema)
	// Taints for the nodes in this group.
	Taint []TaintObservation `json:"taint,omitempty" tf:"taint,omitempty"`

	// (Boolean) If set to false, nodes in this group will not have access to utility network.
	// If set to false, nodes in this group will not have access to utility network.
	UtilityNetworkAccess *bool `json:"utilityNetworkAccess,omitempty" tf:"utility_network_access,omitempty"`
}

type KubernetesNodeGroupParameters struct {

	// affinity policy is considered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.
	// If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is considered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.
	// +kubebuilder:validation:Optional
	AntiAffinity *bool `json:"antiAffinity,omitempty" tf:"anti_affinity,omitempty"`

	// (Block List) Resource properties for Cloud Native plan storage configuration. This block is optional for Cloud Native plans. (see below for nested schema)
	// Resource properties for Cloud Native plan storage configuration. This block is optional for Cloud Native plans.
	// +kubebuilder:validation:Optional
	CloudNativePlan []CloudNativePlanParameters `json:"cloudNativePlan,omitempty" tf:"cloud_native_plan,omitempty"`

	// (String) UUID of the cluster.
	// UUID of the cluster.
	// +crossplane:generate:reference:type=github.com/UpCloudLtd/crossplane-provider-upcloud/apis/namespaced/uks/v1alpha1.KubernetesCluster
	// +kubebuilder:validation:Optional
	Cluster *string `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Reference to a KubernetesCluster in uks to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterRef *v1.NamespacedReference `json:"clusterRef,omitempty" tf:"-"`

	// Selector for a KubernetesCluster in uks to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterSelector *v1.NamespacedSelector `json:"clusterSelector,omitempty" tf:"-"`

	// (Block List) Resource properties for custom plan. This block is required for custom plans only. (see below for nested schema)
	// Resource properties for custom plan. This block is required for `custom` plans only.
	// +kubebuilder:validation:Optional
	CustomPlan []CustomPlanParameters `json:"customPlan,omitempty" tf:"custom_plan,omitempty"`

	// (Block List) Resource properties for GPU plan storage configuration. This block is optional for GPU plans. (see below for nested schema)
	// Resource properties for GPU plan storage configuration. This block is optional for GPU plans.
	// +kubebuilder:validation:Optional
	GpuPlan []GpuPlanParameters `json:"gpuPlan,omitempty" tf:"gpu_plan,omitempty"`

	// -. The API will prefix the arguments with -- when preparing kubelet call.
	// Additional arguments for kubelet for the nodes in this group. Configure the arguments without leading `--`. The API will prefix the arguments with `--` when preparing kubelet call.
	//
	// Note that these arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args.
	// +kubebuilder:validation:Optional
	KubeletArgs []KubeletArgsParameters `json:"kubeletArgs,omitempty" tf:"kubelet_args,omitempty"`

	// value pairs to classify the node_group.
	// User defined key-value pairs to classify the node_group.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Number) Amount of nodes to provision in the node group.
	// Amount of nodes to provision in the node group.
	// +kubebuilder:validation:Optional
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// (String) The server plan used for the node group. You can list available plans with upctl server plans
	// The server plan used for the node group. You can list available plans with `upctl server plans`
	// +kubebuilder:validation:Optional
	Plan *string `json:"plan,omitempty" tf:"plan,omitempty"`

	// (Set of String) You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// +kubebuilder:validation:Optional
	// +listType=set
	SSHKeys []*string `json:"sshKeys,omitempty" tf:"ssh_keys,omitempty"`

	// at-rest and none.
	// The storage encryption strategy to use for the nodes in this group. If not set, the cluster's storage encryption strategy will be used, if applicable. Valid values are `data-at-rest` and `none`.
	// +kubebuilder:validation:Optional
	StorageEncryption *string `json:"storageEncryption,omitempty" tf:"storage_encryption,omitempty"`

	// (Block Set) Taints for the nodes in this group. (see below for nested schema)
	// Taints for the nodes in this group.
	// +kubebuilder:validation:Optional
	Taint []TaintParameters `json:"taint,omitempty" tf:"taint,omitempty"`

	// (Boolean) If set to false, nodes in this group will not have access to utility network.
	// If set to false, nodes in this group will not have access to utility network.
	// +kubebuilder:validation:Optional
	UtilityNetworkAccess *bool `json:"utilityNetworkAccess,omitempty" tf:"utility_network_access,omitempty"`
}

type TaintInitParameters struct {

	// (String) Taint effect.
	// Taint effect.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// (String) Kubelet argument key.
	// Taint key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Taint value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintObservation struct {

	// (String) Taint effect.
	// Taint effect.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// (String) Kubelet argument key.
	// Taint key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Taint value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintParameters struct {

	// (String) Taint effect.
	// Taint effect.
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect" tf:"effect,omitempty"`

	// (String) Kubelet argument key.
	// Taint key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Taint value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

// KubernetesNodeGroupSpec defines the desired state of KubernetesNodeGroup
type KubernetesNodeGroupSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            KubernetesNodeGroupParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider KubernetesNodeGroupInitParameters `json:"initProvider,omitempty"`
}

// KubernetesNodeGroupStatus defines the observed state of KubernetesNodeGroup.
type KubernetesNodeGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        KubernetesNodeGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// KubernetesNodeGroup is the Schema for the KubernetesNodeGroups API. This resource represents a Managed Kubernetes https://upcloud.com/products/managed-kubernetes cluster.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,upcloud}
type KubernetesNodeGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.nodeCount) || (has(self.initProvider) && has(self.initProvider.nodeCount))",message="spec.forProvider.nodeCount is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.plan) || (has(self.initProvider) && has(self.initProvider.plan))",message="spec.forProvider.plan is a required parameter"
	Spec   KubernetesNodeGroupSpec   `json:"spec"`
	Status KubernetesNodeGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KubernetesNodeGroupList contains a list of KubernetesNodeGroups
type KubernetesNodeGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KubernetesNodeGroup `json:"items"`
}

// Repository type metadata.
var (
	KubernetesNodeGroup_Kind             = "KubernetesNodeGroup"
	KubernetesNodeGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: KubernetesNodeGroup_Kind}.String()
	KubernetesNodeGroup_KindAPIVersion   = KubernetesNodeGroup_Kind + "." + CRDGroupVersion.String()
	KubernetesNodeGroup_GroupVersionKind = CRDGroupVersion.WithKind(KubernetesNodeGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&KubernetesNodeGroup{}, &KubernetesNodeGroupList{})
}
