/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CustomPlanInitParameters struct {

	// (Number) The number of CPU cores dedicated to individual node group nodes when using custom plan
	// The number of CPU cores dedicated to individual node group nodes when using custom plan
	Cores *int64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// (Number) The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
	// The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
	Memory *int64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	StorageSize *int64 `json:"storageSize,omitempty" tf:"storage_size,omitempty"`

	// (String) The storage tier to use. Defaults to maxiops
	// The storage tier to use. Defaults to maxiops
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type CustomPlanObservation struct {

	// (Number) The number of CPU cores dedicated to individual node group nodes when using custom plan
	// The number of CPU cores dedicated to individual node group nodes when using custom plan
	Cores *int64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// (Number) The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
	// The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
	Memory *int64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	StorageSize *int64 `json:"storageSize,omitempty" tf:"storage_size,omitempty"`

	// (String) The storage tier to use. Defaults to maxiops
	// The storage tier to use. Defaults to maxiops
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type CustomPlanParameters struct {

	// (Number) The number of CPU cores dedicated to individual node group nodes when using custom plan
	// The number of CPU cores dedicated to individual node group nodes when using custom plan
	// +kubebuilder:validation:Optional
	Cores *int64 `json:"cores" tf:"cores,omitempty"`

	// (Number) The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
	// The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
	// +kubebuilder:validation:Optional
	Memory *int64 `json:"memory" tf:"memory,omitempty"`

	// (Number) The size of the storage device in gigabytes.
	// The size of the storage device in gigabytes.
	// +kubebuilder:validation:Optional
	StorageSize *int64 `json:"storageSize" tf:"storage_size,omitempty"`

	// (String) The storage tier to use. Defaults to maxiops
	// The storage tier to use. Defaults to maxiops
	// +kubebuilder:validation:Optional
	StorageTier *string `json:"storageTier,omitempty" tf:"storage_tier,omitempty"`
}

type KubeletArgsInitParameters struct {

	// (String) Kubelet argument key.
	// Kubelet argument key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Kubelet argument value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type KubeletArgsObservation struct {

	// (String) Kubelet argument key.
	// Kubelet argument key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Kubelet argument value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type KubeletArgsParameters struct {

	// (String) Kubelet argument key.
	// Kubelet argument key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Kubelet argument value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type KubernetesNodeGroupInitParameters struct {

	// affinity policy is considered "best effort" and enabling it does not fully guarantee that the nodes will end up on different hardware.
	// If set to true, nodes in this group will be placed on separate compute hosts.
	// Please note that anti-affinity policy is considered "best effort" and enabling it does not fully guarantee that the nodes will end up on different hardware.
	AntiAffinity *bool `json:"antiAffinity,omitempty" tf:"anti_affinity,omitempty"`

	// (Block List, Max: 1) Resource properties for custom plan (see below for nested schema)
	// Resource properties for custom plan
	CustomPlan []CustomPlanInitParameters `json:"customPlan,omitempty" tf:"custom_plan,omitempty"`

	// those arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args. (see below for nested schema)
	// Additional arguments for kubelet for the nodes in this group. WARNING - those arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args.
	KubeletArgs []KubeletArgsInitParameters `json:"kubeletArgs,omitempty" tf:"kubelet_args,omitempty"`

	// value pairs to classify the node group.
	// Key-value pairs to classify the node group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Number) Amount of nodes to provision in the node group.
	// Amount of nodes to provision in the node group.
	NodeCount *int64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// (String) The server plan used for the node group. You can list available plans with upctl server plans
	// The server plan used for the node group. You can list available plans with `upctl server plans`
	Plan *string `json:"plan,omitempty" tf:"plan,omitempty"`

	// (Set of String) You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// +listType=set
	SSHKeys []*string `json:"sshKeys,omitempty" tf:"ssh_keys,omitempty"`

	// (String) Storage encryption strategy for the nodes in this group.
	// Storage encryption strategy for the nodes in this group.
	StorageEncryption *string `json:"storageEncryption,omitempty" tf:"storage_encryption,omitempty"`

	// (Block Set) Taints for the nodes in this group. (see below for nested schema)
	// Taints for the nodes in this group.
	Taint []TaintInitParameters `json:"taint,omitempty" tf:"taint,omitempty"`

	// (Boolean) If set to false, nodes in this group will not have access to utility network.
	// If set to false, nodes in this group will not have access to utility network.
	UtilityNetworkAccess *bool `json:"utilityNetworkAccess,omitempty" tf:"utility_network_access,omitempty"`
}

type KubernetesNodeGroupObservation struct {

	// affinity policy is considered "best effort" and enabling it does not fully guarantee that the nodes will end up on different hardware.
	// If set to true, nodes in this group will be placed on separate compute hosts.
	// Please note that anti-affinity policy is considered "best effort" and enabling it does not fully guarantee that the nodes will end up on different hardware.
	AntiAffinity *bool `json:"antiAffinity,omitempty" tf:"anti_affinity,omitempty"`

	// (String) UUID of the cluster.
	// UUID of the cluster.
	Cluster *string `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// (Block List, Max: 1) Resource properties for custom plan (see below for nested schema)
	// Resource properties for custom plan
	CustomPlan []CustomPlanObservation `json:"customPlan,omitempty" tf:"custom_plan,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// those arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args. (see below for nested schema)
	// Additional arguments for kubelet for the nodes in this group. WARNING - those arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args.
	KubeletArgs []KubeletArgsObservation `json:"kubeletArgs,omitempty" tf:"kubelet_args,omitempty"`

	// value pairs to classify the node group.
	// Key-value pairs to classify the node group.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Number) Amount of nodes to provision in the node group.
	// Amount of nodes to provision in the node group.
	NodeCount *int64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// (String) The server plan used for the node group. You can list available plans with upctl server plans
	// The server plan used for the node group. You can list available plans with `upctl server plans`
	Plan *string `json:"plan,omitempty" tf:"plan,omitempty"`

	// (Set of String) You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// +listType=set
	SSHKeys []*string `json:"sshKeys,omitempty" tf:"ssh_keys,omitempty"`

	// (String) Storage encryption strategy for the nodes in this group.
	// Storage encryption strategy for the nodes in this group.
	StorageEncryption *string `json:"storageEncryption,omitempty" tf:"storage_encryption,omitempty"`

	// (Block Set) Taints for the nodes in this group. (see below for nested schema)
	// Taints for the nodes in this group.
	Taint []TaintObservation `json:"taint,omitempty" tf:"taint,omitempty"`

	// (Boolean) If set to false, nodes in this group will not have access to utility network.
	// If set to false, nodes in this group will not have access to utility network.
	UtilityNetworkAccess *bool `json:"utilityNetworkAccess,omitempty" tf:"utility_network_access,omitempty"`
}

type KubernetesNodeGroupParameters struct {

	// affinity policy is considered "best effort" and enabling it does not fully guarantee that the nodes will end up on different hardware.
	// If set to true, nodes in this group will be placed on separate compute hosts.
	// Please note that anti-affinity policy is considered "best effort" and enabling it does not fully guarantee that the nodes will end up on different hardware.
	// +kubebuilder:validation:Optional
	AntiAffinity *bool `json:"antiAffinity,omitempty" tf:"anti_affinity,omitempty"`

	// (String) UUID of the cluster.
	// UUID of the cluster.
	// +crossplane:generate:reference:type=github.com/UpCloudLtd/provider-upcloud/apis/uks/v1alpha1.KubernetesCluster
	// +kubebuilder:validation:Optional
	Cluster *string `json:"cluster" tf:"cluster,omitempty"`

	// Reference to a KubernetesCluster in uks to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterRef *v1.Reference `json:"clusterRef,omitempty" tf:"-"`

	// Selector for a KubernetesCluster in uks to populate cluster.
	// +kubebuilder:validation:Optional
	ClusterSelector *v1.Selector `json:"clusterSelector,omitempty" tf:"-"`

	// (Block List, Max: 1) Resource properties for custom plan (see below for nested schema)
	// Resource properties for custom plan
	// +kubebuilder:validation:Optional
	CustomPlan []CustomPlanParameters `json:"customPlan,omitempty" tf:"custom_plan,omitempty"`

	// those arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args. (see below for nested schema)
	// Additional arguments for kubelet for the nodes in this group. WARNING - those arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args.
	// +kubebuilder:validation:Optional
	KubeletArgs []KubeletArgsParameters `json:"kubeletArgs,omitempty" tf:"kubelet_args,omitempty"`

	// value pairs to classify the node group.
	// Key-value pairs to classify the node group.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Number) Amount of nodes to provision in the node group.
	// Amount of nodes to provision in the node group.
	// +kubebuilder:validation:Optional
	NodeCount *int64 `json:"nodeCount" tf:"node_count,omitempty"`

	// (String) The server plan used for the node group. You can list available plans with upctl server plans
	// The server plan used for the node group. You can list available plans with `upctl server plans`
	// +kubebuilder:validation:Optional
	Plan *string `json:"plan" tf:"plan,omitempty"`

	// (Set of String) You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
	// +kubebuilder:validation:Optional
	// +listType=set
	SSHKeys []*string `json:"sshKeys,omitempty" tf:"ssh_keys,omitempty"`

	// (String) Storage encryption strategy for the nodes in this group.
	// Storage encryption strategy for the nodes in this group.
	// +kubebuilder:validation:Optional
	StorageEncryption *string `json:"storageEncryption,omitempty" tf:"storage_encryption,omitempty"`

	// (Block Set) Taints for the nodes in this group. (see below for nested schema)
	// Taints for the nodes in this group.
	// +kubebuilder:validation:Optional
	Taint []TaintParameters `json:"taint,omitempty" tf:"taint,omitempty"`

	// (Boolean) If set to false, nodes in this group will not have access to utility network.
	// If set to false, nodes in this group will not have access to utility network.
	// +kubebuilder:validation:Optional
	UtilityNetworkAccess *bool `json:"utilityNetworkAccess,omitempty" tf:"utility_network_access,omitempty"`
}

type TaintInitParameters struct {

	// (String) Taint effect.
	// Taint effect.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// (String) Kubelet argument key.
	// Taint key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Taint value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintObservation struct {

	// (String) Taint effect.
	// Taint effect.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// (String) Kubelet argument key.
	// Taint key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Taint value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TaintParameters struct {

	// (String) Taint effect.
	// Taint effect.
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect" tf:"effect,omitempty"`

	// (String) Kubelet argument key.
	// Taint key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (String) Kubelet argument value.
	// Taint value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

// KubernetesNodeGroupSpec defines the desired state of KubernetesNodeGroup
type KubernetesNodeGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     KubernetesNodeGroupParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider KubernetesNodeGroupInitParameters `json:"initProvider,omitempty"`
}

// KubernetesNodeGroupStatus defines the observed state of KubernetesNodeGroup.
type KubernetesNodeGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        KubernetesNodeGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// KubernetesNodeGroup is the Schema for the KubernetesNodeGroups API. This resource represents a node group in a Managed Kubernetes cluster.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,upcloud}
type KubernetesNodeGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.nodeCount) || (has(self.initProvider) && has(self.initProvider.nodeCount))",message="spec.forProvider.nodeCount is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.plan) || (has(self.initProvider) && has(self.initProvider.plan))",message="spec.forProvider.plan is a required parameter"
	Spec   KubernetesNodeGroupSpec   `json:"spec"`
	Status KubernetesNodeGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KubernetesNodeGroupList contains a list of KubernetesNodeGroups
type KubernetesNodeGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KubernetesNodeGroup `json:"items"`
}

// Repository type metadata.
var (
	KubernetesNodeGroup_Kind             = "KubernetesNodeGroup"
	KubernetesNodeGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: KubernetesNodeGroup_Kind}.String()
	KubernetesNodeGroup_KindAPIVersion   = KubernetesNodeGroup_Kind + "." + CRDGroupVersion.String()
	KubernetesNodeGroup_GroupVersionKind = CRDGroupVersion.WithKind(KubernetesNodeGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&KubernetesNodeGroup{}, &KubernetesNodeGroupList{})
}
